# PingCAP小作业

## 题目要求

某个机器的配置为：CPU 8 cores, MEM 4G, HDD 4T

这个机器上有一个 1T 的无序数据文件，格式为 (key_size, key, value_size, value)

请设计一个索引结构，使得并发随机地读取每一个 key-value 的代价最小

允许对数据文件做任意预处理，但是预处理的时间计入到整个读取过程的代价里



## 整体思路

- 索引结构为基于全局有序的树状结构。
- 加入内存缓存层，减少IO操作以及控制资源使用量。



## 索引结构

- 将全局有序的`(key,value)`数据分割成8K大小的数据块，每个块按序标号并存成文件，作为树的叶子节点。
- 树的中间节点为8K大小的索引块，内部是有序的`(key,块号)`，用于索引子层中的多个块。
- 当一个索引块不足以索引所有的下层节点时，该层将扩展出多个索引块来索引下一层的块，同时该层也会被更上一层索引，直至最后被唯一的根节点索引。



## 缓存结构

- 为尽可能地减少IO读操作，在内存中保留最常访问的多个块。
- 规定只能通过缓存层访问数据。通过设置缓存块数目，可以控制应用的资源使用量，避免内存不足。
- 当缓存未命中而缓存层满载时，用LRU算法换走旧块，从文件系统中读取新块。

- 文件是已排序的，读取时只需复制到数组中，随后的查找过程采用二分法。



## 查找过程

给定key，查找value的过程如下：

- 从获取根节点索引块开始，通过二分查找其索引数组，找到key对应的下层块。
- 用同样的key，继续查找下层块，直至叶子节点。
- 从叶子节点中的数据块中找到value，返回。



## 实现

### 索引结构的构建

1. 排序阶段

   1.1 采用多路归并的方式进行排序。1T大小的源数据拆分成10个1G大小的数据段，分别在内存中排序、输出到文件。随后打开10个段文件。

   1.2 不断地从这10个段中取最小的key-value，填入8K的缓冲中，直至填满。

   1.3 当8K缓冲填满后，输出成数据块文件，并将其交付给索引构建阶段。随后返回1.2继续循环执行，直至所有key-value读取完成。

2. 索引构建阶段

   2.1 取被交付的下层块的最大key作为index key，往当前层最新索引块填入一条`(index key,块号)`记录。

   2.2 若某一层最新块被填满，则输出成索引块文件，并继续往更上一层提交被填满的索引块，与2.1步形成递归。



### 缓存层

- 若某个块被访问，该块会被Pin住，被Pin住的块不会被LRU算法换出。
- 并发访问安全性的保证：
  - 获取块的方法设为同步方法。
  - 每一个块由读写锁保护，写锁用在复制文件的过程，读锁用在访问内部数组的过程。
- 若某个被请求的块不在缓存层而缓存层已经满了，则用LRU替换器找到将被踢走的块，读取请求块对应的文件，替换掉被提走的块。



## 资源可满足性

```
// TODO
```

